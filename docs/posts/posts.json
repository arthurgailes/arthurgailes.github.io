[
  {
    "path": "posts/2021-02-09-tidytuesday/",
    "title": "Tidy Tuesday: Feb 09,2021",
    "description": "Black wealth and income over time",
    "author": [
      {
        "name": "Arthur Gailes",
        "url": {}
      }
    ],
    "date": "2021-02-16",
    "categories": [
      "tidytuesday",
      "ggplot2"
    ],
    "contents": "\nBlack Wealth Time SeriesThe data this week comes from the Urban Institute and the US Census. The Urban Institute lays out nine charts about racial wealth inequality in America.\nMotivating question\nHow has black wealth and income progressed over time?\nSetup\n\n\n\nLoad the weekly Data\nDownload the weekly data and make available in the tt object.\n\n\n# load tidytuesday data\ntt <- tt_load(\"2021-02-09\")\ntt\n\n\n\nTo answer the motivating question, create a subset of data for black people and save to the local directory:\n\n\n#format data to match the other dfs\nwealth <- tt$race_wealth %>% \n  filter(type=='Median') %>% select(-type)\ninc <- tt$income_mean %>% \n  filter(dollar_type=='2019 Dollars', !grepl('Combination', race)) %>% \n  select(-dollar_type) %>% \n  mutate(race = gsub(' Alone','',race)) %>% \n  # resolve data error\n  distinct(year, race, income_quintile, .keep_all = T) %>% \n  pivot_wider(names_from=income_quintile, values_from=income_dollars, \n    names_prefix = 'Income Quntile: ')\n\n# disaggregate the list into a single dataframe\nbyvars <- c('year','race')\ntt_df_wide <- left_join(tt$home_owner, tt$student_debt, by=byvars) %>% \n  left_join(inc, by=byvars) %>% \n  left_join(wealth, by=byvars) \n\ntt_df <- pivot_longer(tt_df_wide, -c(year, race)) %>% \n  # remove NA values that didn't join\n  filter(!is.na(value))\n\n# filter dataframe to only black people\ntt_df_black <- filter(tt_df, race=='Black')\n\n#write to local directory\nwrite_csv(tt_df_black, 'black_stats.csv')\n\n\n\nGlimpse Data\nTake an initial look at data\n\n\nblack_stats <- read_csv('black_stats.csv', col_types = cols())\nglimpse(black_stats)\n\n\nRows: 318\nColumns: 4\n$ year  <dbl> 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1977, 1977,…\n$ race  <chr> \"Black\", \"Black\", \"Black\", \"Black\", \"Black\", \"Black\",…\n$ name  <chr> \"home_owner_pct\", \"Income Quntile: Lowest\", \"Income Q…\n$ value <dbl> 4.423822e-01, 8.509000e+03, 1.885000e+04, 3.250800e+0…\n\nPrepare Data for Charts\nI create a function to differentiate dollar/percent scales, and then convert the categories of income and wealth to a factor to preserve order.\n\n\n# axis label function\nstat_scales <- function(x){\n  if(mean(x, na.rm=T) < 1) d <- scales::percent(x, accuracy=1)\n  else d <- scales::dollar(x)\n  return(d)\n}\n\nblack_stats_chart <- black_stats %>% \n  mutate(color = ifelse(year<2000, 'green','gray'),\n    namefac = factor(name, levels = c(\"Income Quntile: Lowest\",\"Income Quntile: Second\" ,\n    \"Income Quntile: Middle\", \"Income Quntile: Fourth\",\"Income Quntile: Highest\",\n    \"Income Quntile: Top 5%\", \"wealth_family\",\"home_owner_pct\",\"loan_debt\",\"loan_debt_pct\")),\n    # rename values as needed\n    namefac = fct_recode(namefac, \"Family Wealth\"=\"wealth_family\",\n      \"% Homeowners\"=\"home_owner_pct\",\n      \"Student Loan Debt\"=\"loan_debt\",\"Families w/ Student Loans\"=\"loan_debt_pct\")\n  ) \n\n\n\nVisualize\nDisplay each of the indicators in its own facet. On a cursory glance, it becomes apparent that the year 2000 was an inflection point in most of the data.\n\n\np <- ggplot(black_stats_chart, aes(x=year, y=value, col=year<2000)) +\n  geom_line(size=1.2) +\n  geom_vline(xintercept=2000, col='red', size=1.2)+\n  scale_color_manual(values=c('gray','green'), guide=F)+\n  scale_y_continuous(labels = stat_scales, breaks=scales::pretty_breaks(n=3)) +\n  facet_wrap(vars(namefac), scales='free', nrow=4) +\n  theme_hc() +\n  theme(\n    title=element_text(size=16),\n  ) +\n  labs(title = \"2000: The Year Black Progress Stalled\", x='Year',y='')\np\n\n\n\n\nSave Image\n\n\n# This will save your most recent plot\nggsave(p,\n  filename = \"black_wealth_tt.png\",\n  width=8, height=7,\n  device = \"png\")\n\n\n\n\n\n\n",
    "preview": "posts/2021-02-09-tidytuesday/black_wealth_tt.png",
    "last_modified": "2021-02-16T21:02:03-08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-01-19-tidy-tuesday/",
    "title": "Resizing Polygons by Population Using sf",
    "description": "January 19, 2021 \nTidy Tuesday submission.",
    "author": [
      {
        "name": "Arthur Gailes",
        "url": {}
      }
    ],
    "date": "2021-01-25",
    "categories": [
      "tidytuesday",
      "sf",
      "ggplot2",
      "maps"
    ],
    "contents": "\nResizing Kenya’s county polygonsA quick demonstration of affline transformations with the Kenya Census\nData Source\nThanks as always to the TidyTuesday crew at R4DS.\nThe data this week comes from rKenyaCensus courtesy of Shelmith Kariuki. Shelmith wrote about these datasets on her blog.\n\nrKenyaCensus is an R package that contains the 2019 Kenya Population and Housing Census results. The results were released by the Kenya National Bureau of Statistics in February 2020, and published in four different pdf files (Volume 1 - Volume 4).\n\n\nThe 2019 Kenya Population and Housing Census was the eighth to be conducted in Kenya since 1948 and was conducted from the night of 24th/25th to 31st August 2019. Kenya leveraged on technology to capture data during cartographic mapping, enumeration and data transmission, making the 2019 Census the first paperless census to be conducted in Kenya\n\nAdditional details about Kenya can be found on Wikipedia.\n\nKenya, officially the Republic of Kenya (Swahili: Jamhuri ya Kenya), is a country in Eastern Africa. At 580,367 square kilometres (224,081 sq mi), Kenya is the world’s 48th largest country by total area. With a population of more than 47.6 million people in the 2019 census, Kenya is the 29th most populous country. Kenya’s capital and largest city is Nairobi, while its oldest city and first capital is the coastal city of Mombasa.\n\nLoad the weekly Data\n\n   tidyverse tidytuesdayR         here      ggplot2     ggthemes \n        TRUE         TRUE         TRUE         TRUE         TRUE \nrKenyaCensus           sf    gganimate \n       FALSE         TRUE        FALSE \n\nDowload the weekly data and make available in the tt object. Use the rKenyaCensus to do so, adding the polygons for each county.\n\n\n# grab 3 tables of interest\ncrops <- rKenyaCensus::V4_T2.21\ngender <- rKenyaCensus::V1_T2.2\nhouseholds <- rKenyaCensus::V1_T2.3\ncounties <- rKenyaCensus::KenyaCounties_SHP %>% \n  st_as_sf %>% st_transform(4326)\n\n# write them out\nhouseholds %>% \n  write_csv(\"households.csv\")\n\ngender %>% \n  write_csv(\"gender.csv\")\n\ncrops %>% \n  write_csv(\"crops.csv\")\n\nst_write(counties, \"counties.geojson\", delete_dsn = T)\n\n\n\nAfter saving, load from the directory directly:\n\n\nhouseholds <- read_csv(\"households.csv\")\ngender <- read_csv(\"gender.csv\")\ncrops <- read_csv(\"crops.csv\")\ncounties <- st_read(\"counties.geojson\")\n\n\nReading layer `counties' from data source `/home/kyouma_des/GoogleDrive/AG Resume and Work Stuff/website/_posts/2021-01-19-tidy-tuesday/counties.geojson' using driver `GeoJSON'\nSimple feature collection with 47 features and 7 fields\ngeometry type:  MULTIPOLYGON\ndimension:      XY\nbbox:           xmin: 33.9105 ymin: -4.679729 xmax: 41.91056 ymax: 5.466978\ngeographic CRS: WGS 84\n\nGlimpse Data\nTake an initial look at the format of the data available.\n\n\nhead(counties)\n\n\nSimple feature collection with 6 features and 7 fields\ngeometry type:  MULTIPOLYGON\ndimension:      XY\nbbox:           xmin: 33.9105 ymin: -1.038021 xmax: 37.93755 ymax: 1.653522\ngeographic CRS: WGS 84\n           County Population    Area     PD  PDR  Factor     CRI\n1         BARINGO     666763 11075.3  60.20 0.71 0.00951 0.02902\n2           BOMET     875689  1997.9 438.30 5.20 0.06927 0.21127\n3         BUNGOMA    1670570  2206.9 756.98 8.98 0.11963 0.36487\n4           BUSIA     893681  1628.4 548.81 6.51 0.08673 0.26453\n5 ELGEYO/MARAKWET     454480  3049.7 149.02 1.77 0.02355 0.07183\n6            EMBU     608599  2555.9 238.12 2.82 0.03763 0.11478\n                        geometry\n1 MULTIPOLYGON (((35.78413 1....\n2 MULTIPOLYGON (((35.45192 -0...\n3 MULTIPOLYGON (((34.62083 1....\n4 MULTIPOLYGON (((33.91369 0....\n5 MULTIPOLYGON (((35.5598 1.2...\n6 MULTIPOLYGON (((37.55331 -0...\n\nhead(gender)\n\n\n# A tibble: 6 x 5\n  County         Male   Female Intersex    Total\n  <chr>         <dbl>    <dbl>    <dbl>    <dbl>\n1 Total      23548056 24014716     1524 47564296\n2 Mombasa      610257   598046       30  1208333\n3 Kwale        425121   441681       18   866820\n4 Kilifi       704089   749673       25  1453787\n5 Tana River   158550   157391        2   315943\n6 Lamu          76103    67813        4   143920\n\nWrangle\nTransform country size based on population, then append to the existing dataset. The polygon transformation is conducted in county_size.\n\n\ncentroids <- counties %>% st_geometry %>% \n  st_transform(3857) %>% st_centroid %>% st_transform(4326)\n\ncounty_form <- transmute(counties, county=tools::toTitleCase(County), population=as.numeric(Population), \n  pop_scale=scales::rescale(population, c(0.01,1)), centroid = centroids, type='Colored'\n  ) %>% st_set_crs(4326)\n\n# shift sizes around centroids\ncounty_size <- mutate(county_form, geometry = (geometry-centroid)*pop_scale+centroid,\n  type='Sized') %>% st_set_crs(4326) \n\n# replicate the original shape with NA for population so the color fill can animate\ncounty_blank <- mutate(county_form, population = NA, type='Default')\n\n# bind together for gganimate so I can switch between fill states\ncounty_anim <- bind_rows(county_blank, county_form, county_size) %>% \n  mutate(type = factor(type, c(\"Default\",'Colored','Sized')))\n\n\n\nVisualization\nHow is Kenya’s population distributed across counties? Resize the polygons from 1% to 100% of original size based on the population size. Gif included at the top; this is the code that generated it.\n\n\nanim <- ggplot(county_anim) +\n  geom_sf(aes(fill=population)) +\n  # animation specs\n  transition_states(\n    type, transition_length=1, state_length = 2\n  )+\n  ease_aes('cubic-in-out')+\n  enter_fade()+\n  # back to ggplot; add counties with no fill so outlines stay consistent\n  geom_sf(data=counties, fill=NA) +\n  scale_fill_steps(n.breaks=4, low=\"#bdc9e1\", high=\"#045a8d\", labels=scales::comma,\n    guide='legend', trans='log10') +\n  labs(title=\"Kenya's Counties\", fill='Population') +\n  theme_map() +\n  theme(\n    title=element_text(size=16, color='black')\n  )\n  \nanimate(anim, nframes = 20)\n\n\n\nSave\n\n\nanim_save('kenya_county_size.gif', anim)\n\n\n\nReview\nAn obvious limitation to this approach is that a polygon can only go up to 100% of its original size without exceeding its original boundaries. In this map, the smallest county has the largest population, so the visual impact of the shifts is really messy. A possible cleanup strategy would be to make the original polygons to make them smaller, and so that the population-scaled polygons could increase to fit to the original boundaries.\n\n\n\n",
    "preview": "posts/2021-01-19-tidy-tuesday/kenya_county_size.gif",
    "last_modified": "2021-02-16T21:13:58-08:00",
    "input_file": {}
  }
]
